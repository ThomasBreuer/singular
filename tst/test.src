START_TEST( "test of the singular package" );
if not IsBound(LoadPackage) and IsBound(RequirePackage)  then
  LoadPackage := RequirePackage;
fi;
LoadPackage("singular");
StartSingular();
# Examples from README file
R:=PolynomialRing( Rationals, ["x", "y", "z"]);
gen:=GeneratorsOfLeftOperatorRingWithOne(R);
x:=gen[1];
y:=gen[2];
z:=gen[3];
pol1:=-3*x*z^3+x^3+x*y*z;
pol2:=-3*x^2*z^3+x^4+x^2*y*z-3*x*z^3+x^3+x*y*z;
pol3:=x*y+x*z+x+y+z;
I:=Ideal( R, [ pol1, pol2, pol3] );
SingularSetBaseRing( R );
J:=SingularInterface( "jacob", [ pol1 ], "ideal" );
GeneratorsOfTwoSidedIdeal( J );
SingularInterface( "dim", [ I ], "int" );
std:=SingularInterface( "std", [ I ], "ideal" );
GeneratorsOfTwoSidedIdeal( std );
GroebnerBasis( I );
HasTrivialGroebnerBasis( I );
SingularLibrary( "general.lib");
GcdUsingSingular( pol1, pol2, pol3 );
FactorsUsingSingularNC( pol1 );
FactorsUsingSingular( pol2 );

# Examples from manual
SetInfoLevel( InfoSingular, 2 );
G:= SymmetricGroup( 3 );
R:= PolynomialRing( GF(2), 3 );
gens:=GeneratorsOfInvariantRing( R, G );
I:= Ideal( R, gens );
GB:=GroebnerBasis( I );
R:= PolynomialRing( Rationals, ["x","y","z"] );
i:= IndeterminatesOfPolynomialRing(R);
x:= i[1];
y:= i[2];
z:= i[3];
r:= [ x*y*z -x^2*z, x^2*y*z-x*y^2*z-x*y*z^2, x*y-x*z-y*z];
I:= Ideal( R, r );
GroebnerBasis( I );
R:= PolynomialRing( Rationals, 3 );
i:= IndeterminatesOfPolynomialRing( R );
pols:= [i[1]+i[2]+i[3], i[1]*i[2]+i[1]*i[3]+i[2]*i[3], i[1]*i[2]*i[3]];
o:= MonomialLexOrdering();
GBASIS:= GAPGBASIS;
gg:=GroebnerBasis( pols, o );   # This is the internal GAP method.
GBASIS:= SINGULARGBASIS;
gs:=GroebnerBasis( pols, o );
gg[1]=gs[3] and -gg[4]=gs[2] and gg[5]=gs[1];
I:=Ideal(R, gs);
SingularInterface("reduce", [ gg[2], I ], "poly" );
SingularInterface("reduce", [ gg[3], I ], "poly" );
gs[2] in I;
R:= PolynomialRing( GaussianRationals, ["x","y","z"] );
i:= IndeterminatesOfPolynomialRing(R);
x:= i[1];
y:= i[2];
z:= i[3];
f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
g:= (x*y-z)*(x*y*z^2+x*y^2*z+x^2*y*z);
I:= Ideal( R, [f,g] );
HasTrivialGroebnerBasis( I );
R:= PolynomialRing( Rationals, ["x","y","z"] );
i:= IndeterminatesOfPolynomialRing(R);
x:= i[1];
y:= i[2];
z:= i[3];
f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
g:= (x*y-z)*(x*y*z^2+x*y^2*z+x^2*y*z);
SingularSetBaseRing( R );
GcdUsingSingular( f, g );
f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
SingularSetBaseRing( R );
FactorsUsingSingularNC( f );
m:=[[1,1,1],[0,1,1],[0,0,1]]*One(GF(3));
G:= Group( [m] );
R:= PolynomialRing( GF(3), 3 );
GeneratorsOfInvariantRing( R, G );
R:= PolynomialRing( Rationals, ["x","y","z"] );
i:= IndeterminatesOfPolynomialRing(R);
x:= i[1];
y:= i[2];
z:= i[3];
f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
g:= (x*y-z)*(x*y*z^2+x*y^2*z+x^2*y*z);
I:= Ideal( R, [f,g] );
SingularLibrary("primdec.lib");
pd:=SingularInterface("primdecGTZ", [ I ], "def" );
List(pd,x->List(x,GeneratorsOfTwoSidedIdeal));

# ParseSingProcToGapFunction
SingCommandInStreamOutStream( "", "proc a1 () { return ( 35 ) };" );
SingCommandInStreamOutStream( "", "proc a2 (e2) { return ( a1 ) };" );
SingCommandInStreamOutStream( "", "proc a3 (e3) { return ( a2 ) };" );
f := SingularInterface( "a3", [ 1 ], "proc" );
g := f( 10 );
g(  );
SingCommandInStreamOutStream( "",
 "proc asd ( t ) { return (t+1 ) ;return();};" );
SingCommandInStreamOutStream( "",
 "proc asd2 (){return (asd ) ;return(); };" );
f := SingularInterface( "asd2", [  ], "proc" );
f( 19 );






# this should be at the end of the test file:
SingularNr;
SingularArgument;
SingularBaseRing;
UnderlyingField(SingularBaseRing);
SingularNames;
SingWriteAndReadUntilDone("1;GAP_Apostrophe();2;GAP_Apostrophe();");
SingularInterface("string", "GAP_Done","string");

STOP_TEST( "test", 10 );
