gap> START_TEST( "Test of the singular package" );
gap> if not IsBound(LoadPackage) and IsBound(RequirePackage)  then
>   LoadPackage:= RequirePackage;
> fi;
gap> LoadPackage("singular");
The GAP interface to Singular
true
gap> StartSingular();
#I  Started Singular (version 2004)
gap> # Examples from README file
gap> R:=PolynomialRing( Rationals, ["x", "y", "z"]);
PolynomialRing(..., [ x, y, z ])
gap> gen:=GeneratorsOfLeftOperatorRingWithOne(R);
[ x, y, z ]
gap> x:=gen[1];
x
gap> y:=gen[2];
y
gap> z:=gen[3];
z
gap> pol1:=-3*x*z^3+x^3+x*y*z;
-3*x*z^3+x^3+x*y*z
gap> pol2:=-3*x^2*z^3+x^4+x^2*y*z-3*x*z^3+x^3+x*y*z;
-3*x^2*z^3+x^4+x^2*y*z-3*x*z^3+x^3+x*y*z
gap> pol3:=x*y+x*z+x+y+z;
x*y+x*z+x+y+z
gap> I:=Ideal( R, [ pol1, pol2, pol3] );
<two-sided ideal in PolynomialRing(..., [ x, y, z ]), (3 generators)>
gap> SingularSetBaseRing( R );
gap> J:=SingularInterface( "jacob", [ pol1 ], "ideal" );
<two-sided ideal in PolynomialRing(..., [ x, y, z ]), (3 generators)>
gap> GeneratorsOfTwoSidedIdeal( J );
[ -3*z^3+3*x^2+y*z, x*z, -9*x*z^2+x*y ]
gap> SingularInterface( "dim", [ I ], "int" );
2
gap> std:=SingularInterface( "std", [ I ], "ideal" );
<two-sided ideal in PolynomialRing(..., [ x, y, z ]), (3 generators)>
gap> GeneratorsOfTwoSidedIdeal( std );
[ x*y+x*z+x+y+z, 3*y*z^3+3*z^4-y^2*z-y*z^2+x^2-x-y-z, 
  3*x*z^3-x^3+x*z^2+x*z+y*z+z^2 ]
gap> GroebnerBasis( I );
[ x*y+x*z+x+y+z, 3*y*z^3+3*z^4-y^2*z-y*z^2+x^2-x-y-z, 
  3*x*z^3-x^3+x*z^2+x*z+y*z+z^2 ]
gap> HasTrivialGroebnerBasis( I );
false
gap> SingularLibrary( "general.lib");
gap> GcdUsingSingular( pol1, pol2, pol3 );
1
gap> FactorsUsingSingularNC( pol1 );
[ -1, x, 3*z^3-x^2-y*z ]
gap> FactorsUsingSingular( pol2 );
[ -1, x, x+1, 3*z^3-x^2-y*z ]
gap> 
gap> # Examples from manual
gap> SetInfoLevel( InfoSingular, 2 );
gap> G:= SymmetricGroup( 3 );
Sym( [ 1 .. 3 ] )
gap> R:= PolynomialRing( GF(2), 3 );
PolynomialRing(..., [ x_1, x_2, x_3 ])
gap> gens:=GeneratorsOfInvariantRing( R, G );
[ x_1+x_2+x_3, x_1*x_2+x_1*x_3+x_2*x_3, x_1*x_2*x_3 ]
gap> I:= Ideal( R, gens );
<two-sided ideal in PolynomialRing(..., [ x_1, x_2, x_3 ]), (3 generators)>
gap> GB:=GroebnerBasis( I );
#I  running GroebnerBasis...
#I  done GroebnerBasis.
[ x_1+x_2+x_3, x_2^2+x_2*x_3+x_3^2, x_3^3 ]
gap> R:= PolynomialRing( Rationals, ["x","y","z"] );
PolynomialRing(..., [ x, y, z ])
gap> i:= IndeterminatesOfPolynomialRing(R);
[ x, y, z ]
gap> x:= i[1];
x
gap> y:= i[2];
y
gap> z:= i[3];
z
gap> r:= [ x*y*z -x^2*z, x^2*y*z-x*y^2*z-x*y*z^2, x*y-x*z-y*z];
[ -x^2*z+x*y*z, x^2*y*z-x*y^2*z-x*y*z^2, x*y-x*z-y*z ]
gap> I:= Ideal( R, r );
<two-sided ideal in PolynomialRing(..., [ x, y, z ]), (3 generators)>
gap> GroebnerBasis( I );
#I  running GroebnerBasis...
#I  done GroebnerBasis.
[ x*y-x*z-y*z, x^2*z-x*z^2-y*z^2, x*z^3+y*z^3, -x*z^3+y^2*z^2-y*z^3 ]
gap> R:= PolynomialRing( Rationals, 3 );
PolynomialRing(..., [ x, y, z ])
gap> i:= IndeterminatesOfPolynomialRing( R );
[ x, y, z ]
gap> pols:= [i[1]+i[2]+i[3], i[1]*i[2]+i[1]*i[3]+i[2]*i[3], i[1]*i[2]*i[3]];
[ x+y+z, x*y+x*z+y*z, x*y*z ]
gap> o:= MonomialLexOrdering();
MonomialLexOrdering()
gap> GBASIS:= GAPGBASIS;
rec( name := "naive GAP version of Buchberger's algorithm",
  GroebnerBasis := function( elms, order ) ... end )
gap> gg:=GroebnerBasis( pols, o );   # This is the internal GAP method.
[ x+y+z, x*y+x*z+y*z, x*y*z, -y^2-y*z-z^2, z^3 ]
gap> GBASIS:= SINGULARGBASIS;
rec( name := "singular interface for GroebnerBasis", 
  GroebnerBasis := function( pols, O ) ... end )
gap> gs:=GroebnerBasis( pols, o );
#I  running GroebnerBasis...
#I  done GroebnerBasis.
[ z^3, y^2+y*z+z^2, x+y+z ]
gap> gg[1]=gs[3] and -gg[4]=gs[2] and gg[5]=gs[1];
true
gap> I:=Ideal(R, gs);
<two-sided ideal in PolynomialRing(..., [ x, y, z ]), (3 generators)>
gap> SingularInterface("reduce", [ gg[2], I ], "poly" );
0
gap> SingularInterface("reduce", [ gg[3], I ], "poly" );
0
gap> gs[2] in I;
#I  running GroebnerBasis...
#I  done GroebnerBasis.
true
gap> R:= PolynomialRing( GaussianRationals, ["x","y","z"] );
PolynomialRing(..., [ x, y, z ])
gap> i:= IndeterminatesOfPolynomialRing(R);
[ x, y, z ]
gap> x:= i[1];
x
gap> y:= i[2];
y
gap> z:= i[3];
z
gap> f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
x^3*y*z+x^2*y^2*z+x*y^3*z-x^2*z^2-x*y*z^2-y^2*z^2
gap> g:= (x*y-z)*(x*y*z^2+x*y^2*z+x^2*y*z);
x^3*y^2*z+x^2*y^3*z+x^2*y^2*z^2-x^2*y*z^2-x*y^2*z^2-x*y*z^3
gap> I:= Ideal( R, [f,g] );
<two-sided ideal in PolynomialRing(..., [ x, y, z ]), (2 generators)>
gap> HasTrivialGroebnerBasis( I );
#I  running HasTrivialGroebnerBasis...
#I  done HasTrivialGroebnerBasis.
false
gap> R:= PolynomialRing( Rationals, ["x","y","z"] );
PolynomialRing(..., [ x, y, z ])
gap> i:= IndeterminatesOfPolynomialRing(R);
[ x, y, z ]
gap> x:= i[1];
x
gap> y:= i[2];
y
gap> z:= i[3];
z
gap> f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
x^3*y*z+x^2*y^2*z+x*y^3*z-x^2*z^2-x*y*z^2-y^2*z^2
gap> g:= (x*y-z)*(x*y*z^2+x*y^2*z+x^2*y*z);
x^3*y^2*z+x^2*y^3*z+x^2*y^2*z^2-x^2*y*z^2-x*y^2*z^2-x*y*z^3
gap> SingularSetBaseRing( R );
gap> GcdUsingSingular( f, g );
-x*y*z+z^2
gap> f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
x^3*y*z+x^2*y^2*z+x*y^3*z-x^2*z^2-x*y*z^2-y^2*z^2
gap> SingularSetBaseRing( R );
gap> FactorsUsingSingularNC( f );
[ 1, -x^2-x*y-y^2, -x*y+z, z ]
gap> m:=[[1,1,1],[0,1,1],[0,0,1]]*One(GF(3));
[ [ Z(3)^0, Z(3)^0, Z(3)^0 ], [ 0*Z(3), Z(3)^0, Z(3)^0 ], 
  [ 0*Z(3), 0*Z(3), Z(3)^0 ] ]
gap> G:= Group( [m] );
Group(
[ [ [ Z(3)^0, Z(3)^0, Z(3)^0 ], [ 0*Z(3), Z(3)^0, Z(3)^0 ], [ 0*Z(3), 0*Z(3),
           Z(3)^0 ] ] ])
gap> R:= PolynomialRing( GF(3), 3 );
PolynomialRing(..., [ x_1, x_2, x_3 ])
gap> GeneratorsOfInvariantRing( R, G );
[ x_3, x_1*x_3+x_2^2+x_2*x_3, x_1^3+x_1^2*x_3-x_1*x_2^2-x_1*x_2*x_3 ]
gap> R:= PolynomialRing( Rationals, ["x","y","z"] );
PolynomialRing(..., [ x, y, z ])
gap> i:= IndeterminatesOfPolynomialRing(R);
[ x, y, z ]
gap> x:= i[1];
x
gap> y:= i[2];
y
gap> z:= i[3];
z
gap> f:= (x*y-z)*(x*y*z+y^2*z+x^2*z);
x^3*y*z+x^2*y^2*z+x*y^3*z-x^2*z^2-x*y*z^2-y^2*z^2
gap> g:= (x*y-z)*(x*y*z^2+x*y^2*z+x^2*y*z);
x^3*y^2*z+x^2*y^3*z+x^2*y^2*z^2-x^2*y*z^2-x*y^2*z^2-x*y*z^3
gap> I:= Ideal( R, [f,g] );
<two-sided ideal in PolynomialRing(..., [ x, y, z ]), (2 generators)>
gap> SingularLibrary("primdec.lib");
gap> pd:=SingularInterface("primdecGTZ", [ I ], "def" );
#I  Singular type "list"
[ [ <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (1 generators)>, 
      <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (1 generators)> ], 
  [ <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (1 generators)>, 
      <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (1 generators)> ], 
  [ <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (2 generators)>, 
      <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (2 generators)> ], 
  [ <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (3 generators)>, 
      <two-sided ideal in PolynomialRing(..., [ x, y, z ]), (2 generators)> ] 
 ]
gap> List(pd,x->List(x,GeneratorsOfTwoSidedIdeal));
[ [ [ x*y-z ], [ x*y-z ] ], [ [ z ], [ z ] ], 
  [ [ y^2+y*z+z^2, x+y+z ], [ y^2+y*z+z^2, x+y+z ] ], 
  [ [ y^3, x*y, x^2+y^2 ], [ y, x ] ] ]
gap> 
gap> # ParseSingProcToGapFunction
gap> SingCommandInStreamOutStream( "", "proc a1 () { return ( 35 ) };" );
""
gap> SingCommandInStreamOutStream( "", "proc a2 (e2) { return ( a1 ) };" );
""
gap> SingCommandInStreamOutStream( "", "proc a3 (e3) { return ( a2 ) };" );
""
gap> f := SingularInterface( "a3", [ 1 ], "proc" );
function( e2 ) ... end
gap> g := f( 10 );
#I  Singular type "proc"
function(  ) ... end
gap> g(  );
#I  Singular type "int"
35
gap> SingCommandInStreamOutStream( "",
>  "proc asd ( t ) { return (t+1 ) ;return();};" );
""
gap> SingCommandInStreamOutStream( "",
>  "proc asd2 (){return (asd ) ;return(); };" );
""
gap> f := SingularInterface( "asd2", [  ], "proc" );
function( t ) ... end
gap> f( 19 );
#I  Singular type "int"
20
gap> 
gap> 
gap> 
gap> 
gap> 
gap> 
gap> # this should be at the end of the test file:
gap> SingularNr;
rec( Session := 1, Process := 0, Input := 476, Output := 476 )
gap> SingularArgument;
1
gap> SingularBaseRing;
PolynomialRing(..., [ x, y, z ])
gap> UnderlyingField(SingularBaseRing);
Rationals
gap> SingularNames;
rec( ideals := 21 )
gap> SingWriteAndReadUntilDone("1;GAP_Apostrophe();2;GAP_Apostrophe();");
"1\n'\n2\n'\n> @\n> "
gap> SingularInterface("string", "GAP_Done","string");
"\n return ( \"@\" ) \n\n;return();\n\n"
gap> STOP_TEST( "test", 10000 );
Test of the singular package
GAP4stones: 12
